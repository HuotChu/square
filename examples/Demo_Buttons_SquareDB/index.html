<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>SquareJS Button Demo</title>

    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="../socialshares/css/buttons.css" />
    <script src="../socialshares/js/buttons.js"></script>
</head>
<body>
<a id="forkme_banner" href="https://github.com/blujagu/square">View on GitHub</a>
<div class="social">
    <!-- Twitter button -->
    <a class="share-btn share-btn-branded share-btn-twitter"
       href="https://twitter.com/share?url=http%3A%2F%2Fsquarejs.com&via=@SquareJSdev&hashtags=SquareJS"
       title="Share on Twitter">
        <span class="share-btn-icon"></span>
        <span class="share-btn-text">Twitter</span>
    </a>
    <!-- Facebook button -->
    <a class="share-btn share-btn-branded share-btn-facebook"
       href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fsquarejs.com"
       title="Share on Facebook">
        <span class="share-btn-icon"></span>
        <span class="share-btn-text">Facebook</span>
    </a>
    <!-- Google+ button -->
    <a class="share-btn share-btn-branded share-btn-googleplus"
       href="https://plus.google.com/share?url=http%3A%2F%2Fsquarejs.com"
       title="Share on Google+">
        <span class="share-btn-icon"></span>
        <span class="share-btn-text">Google+</span>
    </a>
</div>
<div id="button-demo"></div>
<div id="tutorial">
    <h1>Square[JS] "Buttons" Demo & Tutorial</h1>
    <p id="author">by Scott Bishop</p>
    <hr />
    <h2>Overview</h2>
    <hr />
    <p class="content">
        There should be five buttons in the upper-left portion of your screen with the labels <b>Galaxy</b>, <b>Nexus</b>, <b>Lenovo</b>, <b>Apple</b>, and <b>Sony</b>.
        There could easily be more or less of these buttons on the screen, because the Square templating engine, temple.js, is creating one button for each `product object` in the database.
        There's more than templating going on here, though. Box (box.js) has dynamically assigned event handlers to each of those buttons. Here's where it
        gets <i>really</i> cool; two things... First, Box keeps track of all those button DOM nodes and it does so during DOM creation of the nodes, so it's fast.
        The framework never has to search through the entire DOM to find and cache the nodes and you will never trigger a DOM search since the nodes are all properties
        of the Box object. Neat, but the other thing that happens here is even better. When a user clicks the button, a query is automatically triggered against the model
        to look up the data being requested by the button push. In this case, when I push a button, I want to know what the description text is that matches that button.
        Ok, so I push a button and the model responds with data, big deal, right? Actually, it is a big deal. The model may respond with the data, but the
        button doesn't care about that. Why should it, it's just a button! Hidden away until needed, there's a `description` div element on the page. If you click a button
        the div will appear with the correct description on it. Box hooked that div element up to the eventHub, so when a read operations is applied to the model it throws a JavaScript
        event. The div is listening for that event and updates itself! That's great, because the description div <i>is</i> what cares about the data. This mechanism is how one and two way data
        binding are achieved in Square without the need for loops or pub/sub.
    </p>
    <p class="content">
        Now that you understand what the demo is doing "under the hood", let's look at how to build it.
        <br /><br />
        <b>Requirements:</b>
        <br /><br />
        - <i>Fetch json data to get a list of devices.</i>
        <br />
        - <i>Create a button for each device name.</i>
        <br />
        - <i>When a button is clicked, the matching device description should appear below the buttons.</i>
     </p>
    <hr />
    <p class="content">
        At the root of the project, there are seven files: index.html, overlay.png, style.css, product.html, productBox.js, and productModel.js. I won't go into detail about overlay.png or style.css
        as these files are simply used to make things look pretty. Also, note the SquareJS directory is not shown. This is discussed in the following index.html breakdown.
    </p>
    <div>
        <img src="../demo_1_directories.png" alt="button demo directory structure" />
    </div>
    <hr />
    <h2>Configuration</h2>
    <hr />
    <p class="content">
        Index.html is where the framework and application are configured prior to initializing the app. Moving from top to bottom within the BODY of this file,
        there are three items on the page which are used to prepare the app before it runs.
    </p>
    <div class="codeBlock">
        <h3>Index.html</h3>
        <p>
            This element will be used to attach the view to the DOM when the view is ready.
        </p>
        <p class="code">
            &lt;div id="button-demo"&gt;&lt;/div&gt;
        </p>

        <p>
            Include require.js which is used to load all the modules. The relative path shows require is located outside the main application directory. This is purely a matter of preference.
            You may place require and square in locations that best suite your project.
        </p>
        <p class="code">
            &lt;script src="../../lib/require.js"&gt;&lt;/script&gt;
        </p>

        <p>
            A require.js configuration block must be included before the app runs.
            <br /><br />
            <b>baseUrl</b> <i>string</i> sets the base directory of the application relative to this file.
            <br /><br />
            <b>paths</b> <i>object</i> maps all the SquareJS modules to module names, so the app will know where to find them.
            <br /><br />
            <b>deps</b> <i>array</i> loads any application dependencies. I added productBox.js, causing it to load. When the
            productBox module loads it creates and attaches the view. Before productBox can even be a "thing" though, we should back up
            and create the html template for buttons and description.
        </p>
        <p class="code">
                &lt;script&gt;<br />
                &nbsp;&nbsp;&nbsp;require.config({<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseUrl: './',<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paths: {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"box": "../../lib/box",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"db": "../../lib/squaredb/squaredb",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"eventHub": "../../lib/eventHub",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"notify": "../../lib/notify",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"request": "../../lib/request",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"square": "../../lib/square",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"aggregates": "../../lib/squaredb/aggregates",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"comparator":  "../../lib/squaredb/comparator",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Select":  "../../lib/squaredb/Select",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"go": "../../lib/squaredb/go",<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"temple": "../../lib/temple"<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deps: ['productBox']<br />
                &lt;/script&gt;
        </p>
    </div>

    <hr />
    <h2>Templating with Temple</h2>
    <hr />
    <p class="content">
        The templating structure is pretty simple. Start with a single element and put your required html inside it. Variables which should be replaced by data values are
        denoted with {{variableName}}. If the variable is inside a repeating element, the syntax includes a plus symbol {{+variableName}}.
    </p>
    <div class="codeBlock">
        <h3>product.html</h3>
        <p class="content">
            `data-` property tags are used to give temple special instructions.
            <br /><br />
            <b>data-repeat</b> tells temple to repeat this element and any child elements. The value for data-repeat is "devices" which will match a `devices` array in the data structure.
            <br /><br />
            <b>data-index</b> tells temple to store this element as a property for later lookup. This is required for any element that will have event handlers or data-binding attached.
            <br />
            The value of data-index is used as the property name to look up for retrieval, therefor every data-index in a box must be unique. To accomplish this, I create a data-index
            that begins with the prefix `productButton_` followed by the `id` of the device associated with this button. That productButton_ prefix will come in handy later
            when we want to attach event handlers to all these buttons.
            <br /><br />
            <b>data-event-args-<i>n</i></b> where <i>n</i> begins at zero and is incremented for each additional data-event-args tag. The value of each data-event-args tag is passed
            as an argument to any callback function used as an event handler targeting the element.
            <br /><br />
            In this case, the `id` of each button will be passed in as the first argument to any event handler we later attach to the button. This will serve as a lookup key to
            get the correct description from the model.
        </p>
        <p class="code">
            &lt;span&gt;<br />
            &nbsp;&nbsp;&nbsp;&lt;ul&gt;<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li data-repeat="devices"&gt;<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span class="button" data-index="productButton_{{+id}}" data-event-args-0="{{+id}}"&gt;<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{+product}}<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/span&gt;<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/li&gt;<br />
            &nbsp;&nbsp;&nbsp;&lt;/ul><br />
            &nbsp;&nbsp;&nbsp;&lt;div id="description" data-index="desc" class="hidden">&lt;/div&gt;<br />
            &lt;/span&gt;
        </p>
    </div>

    <hr />
    <h2>Model Squared</h2>
    <hr />
    <p class="content">
        Creating the model for our application is incredibly easy, thanks to SquareDB.
    </p>
    <div class="codeBlock">
        <h3>productModel.js</h3>
        <p class="content">
            productModel.js is already well commented, so a quick walk-through should suffice. We start by requesting the devices.json file. Then, when that request
            returns, the data is inserted into a new SquareDB database. This database is hooked up to the eventHub to enable data-binding and event management,
            and the whole thing is returned in an argument to any callback passed to the productModel's `then` method.
        </p>
        <p class="code">
            request('devices.json').then(function (deviceData) {
            <br />
            &nbsp;&nbsp;&nbsp;// get the XHR object from the deviceData argument
            <br />
            &nbsp;&nbsp;&nbsp;// ensures the request completed before executing this code
            <br />
            &nbsp;&nbsp;&nbsp;// parse response json and grab the devices array
            <br />
            &nbsp;&nbsp;&nbsp;var allData = JSON.parse(deviceData['response'])['devices'];
            <br /><br />
            &nbsp;&nbsp;&nbsp;// create a model (database) named Products
            <br />
            &nbsp;&nbsp;&nbsp;var model = db.createDB('Products');
            <br /><br />
            &nbsp;&nbsp;&nbsp;// create a table called devices
            <br />
            &nbsp;&nbsp;&nbsp;model.createTable('Devices');
            <br /><br />
            &nbsp;&nbsp;&nbsp;// copy the data array from the server into the Table
            <br />
            &nbsp;&nbsp;&nbsp;// converts a collection of objects to relational structure
            <br />
            &nbsp;&nbsp;&nbsp; model.insertJsonInto('Devices')(allData);
            <br /><br />
            &nbsp;&nbsp;&nbsp;// connect our model to an eventHub
            <br />
            &nbsp;&nbsp;&nbsp; eventHub.connect(model);
            <br /><br />
            &nbsp;&nbsp;&nbsp;// resolve and pass the model to the handler
            <br />
            &nbsp;&nbsp;&nbsp;resolve(model);
            <br />
            });<br />
        </p>
    </div>

    <hr />
    <h2>Build-A-Box</h2>
    <hr />
    <p class="content">
        Now that we have both a template and a model, it's time to build a box and watch it construct and render our view. Useful things, those boxes. Who knew?
    </p>
    <div class="codeBlock">
        <h3>productBox.js</h3>
        <p>
            The first line of code inside productBox.js <b>define</b>s the `productBox` module based on the file name, then it imports both the box.js module and the productModel.
        </p>
        <p class="code">
            define(['box', 'productModel'], function(Box, productModel) {
        </p>
        <p>
            The model returns a Promise to prevent rendering the UI before we have the data. The Promise's `then` method is used to capture and pass in the actual model.
        </p>
        <p class="code">
            productModel.then(function (model) {
        </p>
        <p>
            Now that we have the model, we need to build our box and to do that, we need to create a boxConfig object. This is just an ordinary object with some rather important
            properties.
        </p>
        <p class="code">
            var boxConfig = {
        </p>
        <p>
            boxConfig properties:
        </p>
        <p>
            <b>model</b> <i>square model object</i> is set to the passed in model argument.
        </p>
        <p class="code">
            model: model,
        </p>
        <p>
            <b>data</b> <i>object</i> maps data in the model to variable names in the html template.
            <br />
            The product.html template has a data-repeat element with the value `devices`, so I need a devices property set to the array of devices.
            <br />
            More specifically, I will need the `product` and `id` of each device in the model, as seen in the template, so I use SquareDB to query for that data.
        </p>
        <p class="code">
            data: {<br />
             &nbsp;&nbsp;&nbsp;devices: model.select('product, id').from('Devices').go()<br />
            },
        </p>
        <p>
            <b>target</b> <i>DOM element | optional</i> if provided, the box will automatically attach the completed view to this DOM element.
        </p>
        <p class="code">
            target: document.querySelector('#button-demo'),
        </p>
        <p>
            <b>template</b> <i>string</i> url of the template file for this view.
        </p>
        <p class="code">
            template: 'product.html',
        </p>
        <p>
            <b>domEvents</b> <i>array of objects</i> each object represents an event handler that needs to be attached to one or more DOM elements.
            <br /><br />
            <b>domEvent <i>object</i></b>
            <br /><br />
            <b>event</b> <i>string</i> name of DOM event to listen for.
            <br /><br />
            <b>id</b> <i>string</i> data-index of DOM element where this handler should be attached OR data-index <i>prefix</i> of multiple elements on which to attach the handler.
            <br /><br />
            The html for each button in the demo has a data-index prefix of `productButton_`, so this event handler will be attached to every button.
            <br /><br />
            <b>callback</b> <i>function</i> When the event is fired, this callback is invoked and passed the following arguments:
            <br /><br />
            If the listening element has a data-event-args-0 attribute, the value of that attribute is passed as the first argument to the callback.
            <br /><br />
            If the listening element has a data-event-args-1 attribute, the value of that attribute is passed as the second argument to the callback and so on with every additional
            data-event-args-<i>n</i> attribute.
            <br /><br />
            The last two arguments passed to the callback are always:
            <br />
            - The element listening for the event
            <br />
            - The box (view) that created the listening DOM element
            <br /><br />
            The demo callback function has a couple of simple jobs. Hide the description element and get a description from the model. I could go ahead and set the
            description field's innerHTML to the return of the database call, but that wouldn't demonstrate the ability to watch for model events, now would it?
        </p>
        <p class="code">
            domEvents: [<br />
            &nbsp;&nbsp;&nbsp;{<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event: 'click',<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: 'productButton_',<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback: function (id, domNode, box) {<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;box.index['desc'].className = 'hidden';<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model.select('desc')<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.from('Devices')<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.where('id', '===', id).go();<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
            &nbsp;&nbsp;&nbsp;}<br />
            ],
        </p>
        <p>
            <br /><br />
            <b>modelEvents</b> <i>array of objects</i>  each object represents an event handler that needs to be attached to a model event.
            <br /><br />
            <b>modelEvent <i>object</i></b>
            <br /><br />
            <b>event</b> <i>string</i> name of model event to listen for.
            <br /><br />
            Figuring out the event name to put here is easy. We care about a read action on the `desc` column. The database is `Products` and the table is `Devices`,
            resulting in a Custom Event named `Products.Devices.desc`. To listen to a particular CRUD (create, read, update, delete) event, attach the crud event name to the Custom Event name,
            for example, `Products.Devices.desc.read`.
            <br /><br />
            <b>id</b> <i>string</i> data-index of DOM element this handler should target OR data-index <i>prefix</i> of multiple elements this handler should target.
            <br /><br />
            The data-index of the description element is  `desc`, so this event handler will target that field.
            <br /><br />
            <b>callback</b> <i>function</i> When the event is fired, this callback is invoked and passed the following arguments:
            <br /><br />
            - The Event object contains a details property which holds information provided by the dispatcher of the event.
            <br />
            - The DOM element this event is targeting.
            <br /><br />
            The demo callback function first sets a timeout to make itself wait half of a second before executing. This is necessary, because the data comes back
            so fast that the description element doesn't have time to animate! The inner-function simply gets the value reported by the model event and sets it
            as the innerHTML of the target element. It then tells the element to show itself again.
        </p>
        <p class="code">
            modelEvents: [<br />
            &nbsp;&nbsp;&nbsp;{<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event: 'Products.Devices.desc.read',<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: 'desc',<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback: function (event, descriptionNode) {<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(function () {<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descriptionNode.innerHTML = event.detail.value[0]['desc'];<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descriptionNode.className = 'show';<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 500);<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
            &nbsp;&nbsp;&nbsp;}<br />
            ]
        </p>
    </div>

    <p>
        <i>
            That concludes the SquareJS "Buttons"  tutorial.
            <br />
            Questions, Comments? Send to dev (at) squaredb (dot) com
        </i>
    </p>
    <br /><br />
</div>
    <script src="../../lib/require.js"></script>
    <script>
        require.config({
            baseUrl: './',
            paths: {
                "box": "../../lib/box",
                "db": "../../lib/squaredb/squaredb",
                "eventHub": "../../lib/eventHub",
                "notify": "../../lib/notify",
                "request": "../../lib/request",
                "square": "../../lib/square",
                "aggregates": "../../lib/squaredb/aggregates",
                "comparator":  "../../lib/squaredb/comparator",
                "Select":  "../../lib/squaredb/Select",
                "go": "../../lib/squaredb/go",
                "temple": "../../lib/temple"
            },
            deps: ['productBox']
        });
    </script>
</body>
</html>